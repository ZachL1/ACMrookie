#### 重置数组

```c++
int a[maxn];
// 按字节赋值，将数组 a 所有元素值置为 x
// x 只能为 0 或 -1
/* <cstring> */
memset(a, x, sizeof(a)); 
/* 对于二维数组，sizeof 可以得出整个数组的大小 */

// x 没有限制
// fill 还可以用于其他序列，接受迭代器作为参数
fill(a, a+maxn, x);

// 另有——fill_n 接受重置个数：
fill_n(vec.begin(), vec.size(), x);
```

#### 字符串IO

```C++
char str[99];
// 输出到字符串
sprintf(str, "1 + 1 = %d", 2); 

// 字符串作输入
sscanf(str, "%d", &n);
```

#### 拷贝数组

```C++
// 从数组a中拷贝k个元素到b 中
memcpy(b, a, sizeof(int)*k);
memcpy(b, a, sizeof(a)); /* 全部拷贝 */
```

#### 重定向 IO 流

```C++
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout); 
```

#### printf 和 scanf 的 * 修饰符

```c++
// printf 的 * 修饰符使用参数来指定字段宽度
// 指定字段宽度为 width
printf("The number is :%*d ", width, number);

// scanf 的 * 修饰符跳过相应的输入项
// 跳过输入的前两个整数，从第三个开始读取
scanf("%*d %*d %d", &n);
```



+ “乘以2”也可写成“<<1”，即“左移一位”。左移4位就是乘以 2^4。
+ 如果一个 key 不足以哈希，不妨用两个 key 。使用二维数组，“多维哈希”。<u>UVa213 紫书p83</u>
+ 在多数据的题目中，一个常见的错误是：在计算完一组数据后某些变量没有重置，影响到下组数据的求解。解决：把牵涉变量定义在循环内即可。
+ 为了缓解浮点误差，可以将计算结果加上一个 EPS 后输出。EPS 通常取一个比最低精度还要小几个数量级的小实数，例如要保留3位小数时取 EPS 为 1e-6。



#### 随机数

```c++
#include <cstdlib>
#include <ctime>
srand((unsigned)time(NULL));
rand() % (b-a+1) + a; // 生成 [0,b-a] 内随机数
```



`getline(cin, str)` 会读取一行中的所有内容，然后去掉结尾的换行符存储到 `str` 中。除了换行符其他所有内容都完全复制存储（包括空格）。



使用类函数宏来代替简单的函数，有助于提高效率，尤其是在循环嵌套中。
**搜集一些常用的方便的宏函数。**





- 前缀表示：
  0x：十六进制
  0：八进制

- 输出表示：
  %x：十六进制
  %d：十进制
  %o：八进制
  若还要输出显示前缀，使用：%#x、%#o

- 允许使用大写或小写的常量后缀，但在转换说明中只能用小写。
  56ll、56LL都表示long long 类型的常量；
  但以long long输出时，`%lld` √，`%LLd` ×