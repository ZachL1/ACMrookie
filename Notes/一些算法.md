模拟只会猜题意，贪心只能过样例，数学上来先打表，DP一般看规律。
组合数学靠运气，计算几何瞎暴力，图论一顿套模板，数论只会GCD。

### 判断素数

```c++
bool isPrim(int num){
    if(num <= 3) //两个较小数另外处理 
        return num > 1;
    //不在6的倍数两侧的一定不是质数
    if(num%6 != 1 && num%6 != 5)
        return false;
    int tmp = sqrt(num);
    //在6的倍数两侧的也可能不是质数
    for(int i=5; i <= tmp; i+=6)
        if(num%i==0 || num%(i+2)==0 )
            return false;
    //排除所有，剩余的是质数
    return true;
}
/* 
另有——素数筛法：
	从小到大枚举所有数，对每一个素数，筛去他所有的倍数，剩下的就都是素数。
	比如：2是素数，筛去4、6...；
		 3没有被筛去，因此3是素数，筛去6、9...；
		 5没有被筛去....... 
*/
```



### 在数列中找出最小的两位数

```c++
include <climits>
void Find(int a[], int n, int &min1, int &min2){
    min1=min2=INT_MAX;
    for(int i=0; i<n; i++){
        if(a[i] < min1){
            min2=min1;
            min1=a[i];
        }
        else if(a[i] < min2)
            min2=a[i];
    }
}
```



### 最大公约数

```c++
// 递归式：gcd(a, b)=gcd(b, a%b);
// 递归边界： gcd(a, 0)=a
int gcd(int a, int b){
    return !b ? a : gcd(b, a%b);
}
/* 
另有——求最小公倍数：
	a, b的最大公约数为 gcd(a, b) ，最小公倍数为 a * b / gcd(a, b)；
	a*b 可能溢出，更恰当的写法是 a / gcd(a, b) * b 
```



### 快速幂

```c++
/* a^b % m 迭代写法 */
LL pow_mod(LL a, LL b, LL m) {
    LL ans = 1;
    while (b > 0) {
        if (b & 1)
            ans = ans * a % m;
        a = a * a % m;
        /* b >> 1; 对long long慎用移位运算符 */
        b /= 2;
    }
    return ans;
}
```

